<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Brown Noise">
    <title>Brown Noise Generator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #2c1810;
            color: #d4a574;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }
        
        .container {
            max-width: 500px;
            width: 100%;
        }
        
        h1 {
            margin-bottom: 30px;
            font-size: 2em;
        }
        
        .section {
            margin: 30px 0;
            padding: 20px;
            background: rgba(212, 165, 116, 0.1);
            border-radius: 10px;
        }
        
        .section h3 {
            margin-top: 0;
            color: #f4c2a1;
        }
        
        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
        }
        
        .display {
            font-size: 2em;
            font-weight: bold;
            margin: 0 20px;
            color: #f4c2a1;
            min-width: 80px;
        }
        
        .small-display {
            font-size: 1.5em;
        }
        
        .arrow-btn {
            background: #8b4513;
            border: none;
            color: white;
            font-size: 2em;
            width: 60px;
            height: 60px;
            border-radius: 10px;
            margin: 5px;
            cursor: pointer;
            touch-action: manipulation;
            user-select: none;
        }
        
        .arrow-btn:hover {
            background: #a0522d;
        }
        
        .arrow-btn:active {
            background: #654321;
            transform: scale(0.95);
        }
        
        .play-btn {
            background: #228b22;
            border: none;
            color: white;
            font-size: 1.5em;
            padding: 20px 40px;
            border-radius: 10px;
            margin: 20px;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .play-btn:hover {
            background: #32cd32;
        }
        
        .play-btn.playing {
            background: #dc143c;
        }
        
        .metronome-btn {
            background: #4169e1;
            border: none;
            color: white;
            font-size: 1.2em;
            padding: 15px 30px;
            border-radius: 8px;
            margin: 10px;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .metronome-btn:hover {
            background: #6495ed;
        }
        
        .metronome-btn.playing {
            background: #ff6347;
        }
        
        .info {
            font-size: 0.9em;
            margin-top: 15px;
            opacity: 0.8;
        }

        .install-hint {
            font-size: 0.8em;
            margin-top: 15px;
            padding: 10px;
            background: rgba(212, 165, 116, 0.1);
            border-radius: 5px;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Brown Noise Generator</h1>
        
        <button class="play-btn" id="playBtn">Start Noise</button>
        
        <div class="section">
            <h3>Brown Noise</h3>
            <div class="controls">
                <button class="arrow-btn" id="upBtn">â–²</button>
                <div class="display" id="betaDisplay">2.0</div>
                <button class="arrow-btn" id="downBtn">â–¼</button>
            </div>
            <div class="info">
                Higher Î² = Deeper brown noise<br>
                Range: 0.5 - 4.0
            </div>
        </div>

        <div class="section">
            <h3>Metronome</h3>
            <button class="metronome-btn" id="metronomeBtn">Start Metronome</button>
            
            <div class="controls">
                <span>BPM:</span>
                <button class="arrow-btn" id="bpmDownBtn">â–¼</button>
                <div class="display small-display" id="bpmDisplay">120</div>
                <button class="arrow-btn" id="bpmUpBtn">â–²</button>
            </div>

            <div class="controls">
                <span>Volume:</span>
                <button class="arrow-btn" id="volDownBtn">â–¼</button>
                <div class="display small-display" id="volDisplay">800Hz</div>
                <button class="arrow-btn" id="volUpBtn">â–²</button>
            </div>
            
            <div class="controls">
                <span>Frequency:</span>
                <button class="arrow-btn" id="freqDownBtn">â–¼</button>
                <div class="display small-display" id="freqDisplay">800Hz</div>
                <button class="arrow-btn" id="freqUpBtn">â–²</button>
            </div>

            <!-- Update the info section (line 182-184) -->
            <div class="info">
                BPM: 30-200 | Volume: 0-100% | Frequency: 200-2000Hz
            </div>
        </div>

        <div class="install-hint">
            ðŸ’¡ For background playback on iOS: Add to Home Screen and use as web app
        </div>
    </div>

    <script>
        class BrownNoiseGenerator {
            constructor() {
                this.audioContext = null;
                this.noiseNode = null;
                this.filterNode = null;
                this.gainNode = null;
                this.metronomeGainNode = null;
                this.masterGainNode = null;
                this.isPlaying = false;
                this.isMetronomeOn = false;
                this.beta = 2.0;
                this.bpm = 120;
                this.metronomeVolume = 0.5;
                this.metronomeInterval = null;
                this.wakeLock = null;
                
                this.initializeElements();
                this.setupEventListeners();
                this.setupMediaSession();
                this.setupVisibilityHandling();

                this.metronomeFrequency = 600;
            }
            
            initializeElements() {
                this.playBtn = document.getElementById('playBtn');
                this.upBtn = document.getElementById('upBtn');
                this.downBtn = document.getElementById('downBtn');
                this.betaDisplay = document.getElementById('betaDisplay');
                this.metronomeBtn = document.getElementById('metronomeBtn');
                this.bpmUpBtn = document.getElementById('bpmUpBtn');
                this.bpmDownBtn = document.getElementById('bpmDownBtn');
                this.volUpBtn = document.getElementById('volUpBtn');
                this.volDownBtn = document.getElementById('volDownBtn');
                this.bpmDisplay = document.getElementById('bpmDisplay');
                this.volDisplay = document.getElementById('volDisplay');
                this.freqUpBtn = document.getElementById('freqUpBtn');
                this.freqDownBtn = document.getElementById('freqDownBtn');
                this.freqDisplay = document.getElementById('freqDisplay');
            }
            
            setupEventListeners() {
                this.playBtn.addEventListener('click', () => this.toggleNoise());
                this.upBtn.addEventListener('click', () => this.adjustBeta(0.1));
                this.downBtn.addEventListener('click', () => this.adjustBeta(-0.1));
                this.metronomeBtn.addEventListener('click', () => this.toggleMetronome());
                this.bpmUpBtn.addEventListener('click', () => this.adjustBPM(5));
                this.bpmDownBtn.addEventListener('click', () => this.adjustBPM(-5));
                this.volUpBtn.addEventListener('click', () => this.adjustMetronomeVolume(5));
                this.volDownBtn.addEventListener('click', () => this.adjustMetronomeVolume(-5));

                this.freqUpBtn.addEventListener('click', () => this.adjustMetronomeFrequency(50));
                this.freqDownBtn.addEventListener('click', () => this.adjustMetronomeFrequency(-50));
            }

            setupMediaSession() {
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: 'Brown Noise Generator',
                        artist: 'Background Audio',
                        artwork: []
                    });

                    navigator.mediaSession.setActionHandler('play', () => {
                        if (!this.isPlaying) this.toggleNoise();
                    });

                    navigator.mediaSession.setActionHandler('pause', () => {
                        if (this.isPlaying) this.toggleNoise();
                    });
                }
            }

            setupVisibilityHandling() {
                document.addEventListener('visibilitychange', () => {
                    if (this.isPlaying && this.audioContext) {
                        if (document.hidden) {
                            this.audioContext.resume();
                        } else {
                            if (this.audioContext.state === 'suspended') {
                                this.audioContext.resume();
                            }
                        }
                    }
                });
            }

            async requestWakeLock() {
                try {
                    if ('wakeLock' in navigator) {
                        this.wakeLock = await navigator.wakeLock.request('screen');
                    }
                } catch (err) {
                    console.log('Wake lock not supported or failed:', err);
                }
            }

            releaseWakeLock() {
                if (this.wakeLock) {
                    this.wakeLock.release();
                    this.wakeLock = null;
                }
            }

            createMetronomeTick() {
                if (!this.audioContext) return;

                const tickDuration = 0.1;
                const sampleRate = this.audioContext.sampleRate;
                const tickBuffer = this.audioContext.createBuffer(1, sampleRate * tickDuration, sampleRate);
                const output = tickBuffer.getChannelData(0);

                // Create metronome tick with harmonics (like a real metronome)
                const fundamental = Math.max(200, this.metronomeFrequency * 0.75); // Slightly lower base
                const harmonics = [1, 2, 3, 4, 5, 7]; // Include 7th for more complex timbre
                const harmonicAmps = [1.0, 0.6, 0.4, 0.25, 0.15, 0.1]; // More gradual falloff

                for (let i = 0; i < output.length; i++) {
                    const t = i / sampleRate;
                    let sample = 0;

                    // Add harmonics
                    for (let h = 0; h < harmonics.length; h++) {
                        const freq = fundamental * harmonics[h];
                        const amp = harmonicAmps[h];
                        sample += Math.sin(2 * Math.PI * freq * t) * amp;
                    }

                    // More natural envelope - sharper attack, longer decay
                    const attack = Math.min(1, t * 200); // Faster attack
                    const decay = Math.exp(-t * 8); // Slower decay for more resonance
                    const envelope = attack * decay;
                    
                    output[i] = sample * envelope * 0.2; // Reduced overall volume
                }

                // Play the tick
                const tickSource = this.audioContext.createBufferSource();
                tickSource.buffer = tickBuffer;
                tickSource.connect(this.metronomeGainNode);
                tickSource.start();
            }

            startMetronome() {
                if (this.metronomeInterval) {
                    clearInterval(this.metronomeInterval);
                }

                const intervalMs = (60 / this.bpm) * 1000;
                this.metronomeInterval = setInterval(() => {
                    this.createMetronomeTick();
                }, intervalMs);

                // Play first tick immediately
                this.createMetronomeTick();
            }

            stopMetronome() {
                if (this.metronomeInterval) {
                    clearInterval(this.metronomeInterval);
                    this.metronomeInterval = null;
                }
            }
            
            async initAudio() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Create master gain node
                    this.masterGainNode = this.audioContext.createGain();
                    this.masterGainNode.connect(this.audioContext.destination);

                    // Create metronome gain node
                    this.metronomeGainNode = this.audioContext.createGain();
                    this.metronomeGainNode.gain.value = this.metronomeVolume;
                    this.metronomeGainNode.connect(this.masterGainNode);
                    
                    // Create noise buffer
                    const bufferSize = this.audioContext.sampleRate * 2;
                    const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    
                    // Generate white noise
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                    
                    // Create nodes
                    this.noiseNode = this.audioContext.createBufferSource();
                    this.noiseNode.buffer = noiseBuffer;
                    this.noiseNode.loop = true;
                    
                    this.filterNode = this.audioContext.createBiquadFilter();
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = 0.3;
                    
                    // Connect nodes
                    this.noiseNode.connect(this.filterNode);
                    this.filterNode.connect(this.gainNode);
                    this.gainNode.connect(this.masterGainNode);
                    
                    this.updateFilter();
                }
            }
            
            updateFilter() {
                if (this.filterNode) {
                    const cutoffFreq = Math.max(50, 2000 / Math.pow(this.beta, 2));
                    this.filterNode.type = 'lowpass';
                    this.filterNode.frequency.value = cutoffFreq;
                    this.filterNode.Q.value = this.beta * 0.5;
                }
            }
            
            async toggleNoise() {
                if (!this.isPlaying) {
                    await this.initAudio();
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    this.noiseNode.start();
                    this.isPlaying = true;
                    this.playBtn.textContent = 'Stop Noise';
                    this.playBtn.classList.add('playing');
                    
                    if ('mediaSession' in navigator) {
                        navigator.mediaSession.playbackState = 'playing';
                    }
                    
                    await this.requestWakeLock();
                } else {
                    this.noiseNode.stop();
                    this.noiseNode = null;
                    this.audioContext = null;
                    this.isPlaying = false;
                    this.playBtn.textContent = 'Start Noise';
                    this.playBtn.classList.remove('playing');
                    
                    // Stop metronome if running
                    if (this.isMetronomeOn) {
                        this.toggleMetronome();
                    }
                    
                    if ('mediaSession' in navigator) {
                        navigator.mediaSession.playbackState = 'paused';
                    }
                    
                    this.releaseWakeLock();
                }
            }

            async toggleMetronome() {
                if (!this.isMetronomeOn) {
                    if (!this.audioContext) {
                        await this.initAudio();
                        if (this.audioContext.state === 'suspended') {
                            await this.audioContext.resume();
                        }
                    }
                    this.startMetronome();
                    this.isMetronomeOn = true;
                    this.metronomeBtn.textContent = 'Stop Metronome';
                    this.metronomeBtn.classList.add('playing');
                } else {
                    this.stopMetronome();
                    this.isMetronomeOn = false;
                    this.metronomeBtn.textContent = 'Start Metronome';
                    this.metronomeBtn.classList.remove('playing');
                }
            }
            
            adjustBeta(delta) {
                this.beta = Math.max(0.5, Math.min(4.0, this.beta + delta));
                this.betaDisplay.textContent = this.beta.toFixed(1);
                this.updateFilter();
            }

            adjustBPM(delta) {
                this.bpm = Math.max(30, Math.min(200, this.bpm + delta));
                this.bpmDisplay.textContent = this.bpm.toString();
                
                // Restart metronome with new BPM if it's running
                if (this.isMetronomeOn) {
                    this.startMetronome();
                }
            }

            adjustMetronomeVolume(delta) {
                const volumePercent = Math.max(0, Math.min(100, Math.round(this.metronomeVolume * 100) + delta));
                this.metronomeVolume = volumePercent / 100;
                this.volDisplay.textContent = volumePercent + '%';
                
                if (this.metronomeGainNode) {
                    this.metronomeGainNode.gain.value = this.metronomeVolume;
                }
            }

            adjustMetronomeFrequency(delta) {
                this.metronomeFrequency = Math.max(200, Math.min(2000, this.metronomeFrequency + delta));
                this.freqDisplay.textContent = this.metronomeFrequency + 'Hz';
            }
        }
        
        // Initialize the generator when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new BrownNoiseGenerator();
        });
    </script>
</body>
</html>

